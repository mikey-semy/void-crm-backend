"""
WebSocket Manager Ğ´Ğ»Ñ real-time ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸.

Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Redis PubSub Ğ´Ğ»Ñ
Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ (ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ ÑĞµÑ€Ğ²ĞµÑ€Ğ°Ğ¼Ğ¸).
ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¸ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°.
"""

import asyncio
import json
import logging
from dataclasses import asdict, dataclass, field
from datetime import UTC, datetime
from typing import Any
from uuid import UUID

from fastapi import WebSocket
from redis.asyncio import Redis

logger = logging.getLogger(__name__)


@dataclass
class OnlineUser:
    """Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ."""

    user_id: str
    username: str
    full_name: str | None
    role: str
    status: str = "online"  # online, away, idle
    connected_at: str = field(default_factory=lambda: datetime.now(UTC).isoformat())
    last_activity_at: str = field(default_factory=lambda: datetime.now(UTC).isoformat())

    def to_dict(self) -> dict[str, Any]:
        """ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµÑ‚ Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ´Ğ»Ñ JSON."""
        return asdict(self)


@dataclass
class AuthenticatedConnection:
    """WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ."""

    websocket: WebSocket
    user: OnlineUser


class ConnectionManager:
    """
    ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Redis PubSub.

    Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼Ğ¸ WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¸ Ñ€Ğ°ÑÑÑ‹Ğ»Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    Ñ‡ĞµÑ€ĞµĞ· Redis PubSub Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¸ Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.
    ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.

    Attributes:
        active_connections: Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ (Ğ±ĞµĞ· Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)
        authenticated_connections: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹ {user_id: connection}
        redis: Redis ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ PubSub
        pubsub: Redis PubSub Ğ¾Ğ±ÑŠĞµĞºÑ‚
        channel_name: ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ğ° Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹

    Example:
        >>> manager = ConnectionManager(redis_client)
        >>> await manager.connect_authenticated(websocket, user_data)
        >>> await manager.broadcast({"type": "task:updated", "data": {...}})
    """

    def __init__(self, redis: Redis | None = None, channel: str = "checklist:updates"):
        """
        Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚ ConnectionManager.

        Args:
            redis: Redis ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ PubSub (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
            channel: ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ğ° Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
        """
        self.active_connections: list[WebSocket] = []
        self.authenticated_connections: dict[str, AuthenticatedConnection] = {}
        self.redis = redis
        self.pubsub = None
        self.channel_name = channel
        self._listener_task: asyncio.Task | None = None

    async def connect(self, websocket: WebSocket) -> None:
        """
        ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ….

        Args:
            websocket: WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ

        Example:
            >>> await manager.connect(websocket)
        """
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(
            "WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½. ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹: %d", len(self.active_connections)
        )

        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ listener Ğ´Ğ»Ñ Redis PubSub, ĞµÑĞ»Ğ¸ ĞµÑ‰Ğµ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½
        if self.redis and not self._listener_task:
            await self._start_pubsub_listener()

    async def connect_authenticated(
        self,
        websocket: WebSocket,
        user_id: str | UUID,
        username: str,
        full_name: str | None,
        role: str,
    ) -> OnlineUser:
        """
        ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ.

        Args:
            websocket: WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
            user_id: ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            username: Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            full_name: ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ
            role: Ğ Ğ¾Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

        Returns:
            OnlineUser: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ

        Example:
            >>> user = await manager.connect_authenticated(
            ...     websocket, user.id, user.username, user.full_name, "admin"
            ... )
        """
        await websocket.accept()

        user_id_str = str(user_id)
        online_user = OnlineUser(
            user_id=user_id_str,
            username=username,
            full_name=full_name,
            role=role,
        )

        # Ğ•ÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½, Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
        if user_id_str in self.authenticated_connections:
            old_conn = self.authenticated_connections[user_id_str]
            try:
                await old_conn.websocket.close(code=4000, reason="ĞĞ¾Ğ²Ğ¾Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ")
            except Exception:
                pass
            logger.info("Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¾ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ %s", username)

        self.authenticated_connections[user_id_str] = AuthenticatedConnection(
            websocket=websocket,
            user=online_user,
        )

        logger.info(
            "ğŸŸ¢ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ %s Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½. Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½: %d",
            username,
            len(self.authenticated_connections),
        )

        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ listener Ğ´Ğ»Ñ Redis PubSub, ĞµÑĞ»Ğ¸ ĞµÑ‰Ğµ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½
        if self.redis and not self._listener_task:
            await self._start_pubsub_listener()

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²ÑĞµÑ… Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½
        await self.notify_user_online(online_user)

        return online_user

    def disconnect(self, websocket: WebSocket) -> None:
        """
        Ğ£Ğ´Ğ°Ğ»ÑĞµÑ‚ WebSocket Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹.

        Args:
            websocket: WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ

        Example:
            >>> manager.disconnect(websocket)
        """
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            logger.info(
                "WebSocket Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½. ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹: %d",
                len(self.active_connections),
            )

        # ĞÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ listener ĞµÑĞ»Ğ¸ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
        if (
            not self.active_connections
            and not self.authenticated_connections
            and self._listener_task
        ):
            self._stop_pubsub_listener()

    async def disconnect_authenticated(self, user_id: str | UUID) -> OnlineUser | None:
        """
        ĞÑ‚ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.

        Args:
            user_id: ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

        Returns:
            OnlineUser | None: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ñ‘Ğ½Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ Ğ¸Ğ»Ğ¸ None

        Example:
            >>> user = await manager.disconnect_authenticated(user_id)
        """
        user_id_str = str(user_id)

        if user_id_str not in self.authenticated_connections:
            return None

        connection = self.authenticated_connections.pop(user_id_str)
        online_user = connection.user

        logger.info(
            "ğŸ”´ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ %s Ğ¾Ñ„Ñ„Ğ»Ğ°Ğ¹Ğ½. Ğ’ÑĞµĞ³Ğ¾ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½: %d",
            online_user.username,
            len(self.authenticated_connections),
        )

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²ÑĞµÑ… Ğ¾ Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒÑˆÑ‘Ğ»
        await self.notify_user_offline(online_user)

        # ĞÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ listener ĞµÑĞ»Ğ¸ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
        if (
            not self.active_connections
            and not self.authenticated_connections
            and self._listener_task
        ):
            self._stop_pubsub_listener()

        return online_user

    def get_online_users(self) -> list[dict[str, Any]]:
        """
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.

        Returns:
            list[dict]: Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑĞ»Ğ¾Ğ²Ğ°Ñ€ĞµĞ¹ Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑÑ…

        Example:
            >>> users = manager.get_online_users()
            >>> # [{"user_id": "...", "username": "admin", ...}, ...]
        """
        return [conn.user.to_dict() for conn in self.authenticated_connections.values()]

    def get_online_count(self) -> int:
        """
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.

        Returns:
            int: ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
        """
        return len(self.authenticated_connections)

    def is_user_online(self, user_id: str | UUID) -> bool:
        """
        ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ.

        Args:
            user_id: ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

        Returns:
            bool: True ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½
        """
        return str(user_id) in self.authenticated_connections

    async def send_personal_message(
        self, message: dict[str, Any], websocket: WebSocket
    ) -> None:
        """
        ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¼Ñƒ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ.

        Args:
            message: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸
            websocket: Ğ¦ĞµĞ»ĞµĞ²Ğ¾Ğµ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ

        Example:
            >>> await manager.send_personal_message(
            ...     {"type": "connection:established"},
            ...     websocket
            ... )
        """
        try:
            await websocket.send_json(message)
            logger.debug("ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: %s", message.get("type"))
        except Exception as e:
            logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ: %s", e)
            self.disconnect(websocket)

    async def send_to_user(self, user_id: str | UUID, message: dict[str, Any]) -> bool:
        """
        ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.

        Args:
            user_id: ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            message: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸

        Returns:
            bool: True ĞµÑĞ»Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾

        Example:
            >>> await manager.send_to_user(user_id, {"type": "notification", ...})
        """
        user_id_str = str(user_id)
        if user_id_str not in self.authenticated_connections:
            return False

        connection = self.authenticated_connections[user_id_str]
        try:
            await connection.websocket.send_json(message)
            return True
        except Exception as e:
            logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ %s: %s", user_id_str, e)
            await self.disconnect_authenticated(user_id_str)
            return False

    async def broadcast(
        self, message: dict[str, Any], exclude: WebSocket | None = None
    ) -> None:
        """
        Ğ Ğ°ÑÑÑ‹Ğ»Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼.

        Ğ•ÑĞ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Redis, Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² PubSub ĞºĞ°Ğ½Ğ°Ğ»
        Ğ´Ğ»Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼Ğ¸ ÑĞµÑ€Ğ²ĞµÑ€Ğ°Ğ¼Ğ¸.

        Args:
            message: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸
            exclude: WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¸ÑĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ· Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸

        Example:
            >>> await manager.broadcast({
            ...     "type": "task:updated",
            ...     "data": {"id": "...", "status": "completed"}
            ... })
        """
        # Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼
        await self._broadcast_local(message, exclude)

        # ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ² Redis PubSub Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ²
        if self.redis:
            await self._publish_to_redis(message)

    async def _broadcast_local(
        self, message: dict[str, Any], exclude: WebSocket | None = None
    ) -> None:
        """
        Ğ Ğ°ÑÑÑ‹Ğ»Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼.

        Args:
            message: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸
            exclude: WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
        """
        disconnected = []

        # Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ½ĞµĞ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼
        for connection in self.active_connections:
            if connection == exclude:
                continue

            try:
                await connection.send_json(message)
            except Exception as e:
                logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ: %s", e)
                disconnected.append(connection)

        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
        for conn in disconnected:
            self.disconnect(conn)

        if disconnected:
            logger.info("ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ %d ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¸ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞµ", len(disconnected))

        # Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼
        disconnected_users = []
        for user_id, auth_conn in self.authenticated_connections.items():
            if auth_conn.websocket == exclude:
                continue

            try:
                await auth_conn.websocket.send_json(message)
            except Exception as e:
                logger.error(
                    "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ %s: %s",
                    auth_conn.user.username,
                    e,
                )
                disconnected_users.append(user_id)

        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
        for user_id in disconnected_users:
            await self.disconnect_authenticated(user_id)

    async def _publish_to_redis(self, message: dict[str, Any]) -> None:
        """
        ĞŸÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Redis PubSub ĞºĞ°Ğ½Ğ°Ğ».

        Args:
            message: Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
        """
        try:
            message_json = json.dumps(message, default=str)
            await self.redis.publish(self.channel_name, message_json)
            logger.debug("ĞĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Redis: %s", message.get("type"))
        except Exception as e:
            logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ² Redis: %s", e)

    async def _start_pubsub_listener(self) -> None:
        """
        Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ Ñ„Ğ¾Ğ½Ğ¾Ğ²ÑƒÑ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ Redis PubSub ĞºĞ°Ğ½Ğ°Ğ»Ğ°.

        ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¸Ğ· Redis Ğ¸ Ñ€Ğ°ÑÑÑ‹Ğ»Ğ°ĞµÑ‚ Ğ¸Ñ… Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼.
        """
        try:
            self.pubsub = self.redis.pubsub()
            await self.pubsub.subscribe(self.channel_name)
            self._listener_task = asyncio.create_task(self._listen_redis())
            logger.info(
                "Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Redis PubSub listener Ğ´Ğ»Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°: %s", self.channel_name
            )
        except Exception as e:
            logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Redis PubSub listener: %s", e)

    def _stop_pubsub_listener(self) -> None:
        """
        ĞÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ„Ğ¾Ğ½Ğ¾Ğ²ÑƒÑ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ Redis PubSub.
        """
        if self._listener_task:
            self._listener_task.cancel()
            self._listener_task = None
            logger.info("ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Redis PubSub listener")

    async def _listen_redis(self) -> None:
        """
        Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¸Ğ· Redis PubSub.

        ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¸ Ñ€Ğ°ÑÑÑ‹Ğ»Ğ°ĞµÑ‚ Ğ¸Ñ… Ğ²ÑĞµĞ¼ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ÑĞ¼.
        ĞŸÑ€Ğ¸ Ñ€Ğ°Ğ·Ñ€Ñ‹Ğ²Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ÑÑ.
        """
        retry_delay = 1.0
        max_retry_delay = 60.0

        while True:
            try:
                async for message in self.pubsub.listen():
                    if message["type"] == "message":
                        try:
                            data = json.loads(message["data"])
                            await self._broadcast_local(data)
                            logger.debug(
                                "ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Redis: %s", data.get("type")
                            )
                        except json.JSONDecodeError as e:
                            logger.error("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ JSON Ğ¸Ğ· Redis: %s", e)
                    # Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ğ¿Ñ€Ğ¸ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
                    retry_delay = 1.0
            except asyncio.CancelledError:
                logger.info("Redis PubSub listener Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")
                await self.pubsub.unsubscribe(self.channel_name)
                await self.pubsub.close()
                break
            except Exception as e:
                logger.error(
                    "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² Redis PubSub listener: %s, Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· %s ÑĞµĞº",
                    e,
                    retry_delay,
                )
                await asyncio.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, max_retry_delay)

                # ĞŸĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ÑÑ Ğº Redis PubSub
                try:
                    await self.pubsub.close()
                    self.pubsub = self.redis.pubsub()
                    await self.pubsub.subscribe(self.channel_name)
                    logger.info("âœ¨ ĞŸĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ğ»Ğ¸ÑÑŒ Ğº Redis PubSub")
                except Exception as reconnect_error:
                    logger.error(
                        "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Redis PubSub: %s", reconnect_error
                    )

    # ===== Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑÑ… =====

    async def notify_user_online(self, user: OnlineUser) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾ Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½.

        Args:
            user: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ

        Example:
            >>> await manager.notify_user_online(online_user)
        """
        message = {
            "type": "user:online",
            "data": user.to_dict(),
        }
        await self.broadcast(message)

    async def notify_user_offline(self, user: OnlineUser) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾ Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¾Ñ„Ñ„Ğ»Ğ°Ğ¹Ğ½.

        Args:
            user: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¾Ñ„Ñ„Ğ»Ğ°Ğ¹Ğ½-Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ

        Example:
            >>> await manager.notify_user_offline(online_user)
        """
        message = {
            "type": "user:offline",
            "data": user.to_dict(),
        }
        await self.broadcast(message)

    async def notify_user_updated(self, user_id: str, user_data: dict[str, Any]) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾Ğ± Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.

        Ğ¢Ğ°ĞºĞ¶Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² authenticated_connections.

        Args:
            user_id: UUID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            user_data: ĞĞ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (username, full_name, role)

        Example:
            >>> await manager.notify_user_updated(
            ...     str(user_id),
            ...     {"username": "new_name", "full_name": "ĞĞ¾Ğ²Ğ¾Ğµ Ğ¤Ğ˜Ğ"}
            ... )
        """
        user_id_str = str(user_id)

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² authenticated_connections ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½
        if user_id_str in self.authenticated_connections:
            conn = self.authenticated_connections[user_id_str]
            old_user = conn.user
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ OnlineUser Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
            updated_user = OnlineUser(
                user_id=old_user.user_id,
                username=user_data.get("username", old_user.username),
                full_name=user_data.get("full_name", old_user.full_name),
                role=user_data.get("role", old_user.role),
                connected_at=old_user.connected_at,
            )
            self.authenticated_connections[user_id_str] = AuthenticatedConnection(
                websocket=conn.websocket,
                user=updated_user,
            )

            # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°Ğ¼
            message = {
                "type": "user:updated",
                "data": updated_user.to_dict(),
            }
            await self.broadcast(message)

            logger.info(
                "ğŸ“ ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ %s Ğ² ÑĞ¿Ğ¸ÑĞºĞµ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½",
                updated_user.username,
            )

    # ===== Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°Ñ… =====

    async def notify_task_updated(self, task_id: UUID, task_data: dict[str, Any]) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾Ğ± Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸.

        Args:
            task_id: UUID Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
            task_data: Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

        Example:
            >>> await manager.notify_task_updated(
            ...     task_id,
            ...     {"id": str(task_id), "status": "completed", ...}
            ... )
        """
        message = {"type": "task:updated", "data": {"id": str(task_id), **task_data}}
        await self.broadcast(message)

    async def notify_category_updated(
        self, category_id: UUID, category_data: dict[str, Any]
    ) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾Ğ± Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸.

        Args:
            category_id: UUID Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
            category_data: Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸

        Example:
            >>> await manager.notify_category_updated(
            ...     category_id,
            ...     {"id": str(category_id), "title": "ĞĞ¾Ğ²Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ", ...}
            ... )
        """
        message = {
            "type": "category:updated",
            "data": {"id": str(category_id), **category_data},
        }
        await self.broadcast(message)

    async def notify_task_created(self, task_data: dict[str, Any]) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸.

        Args:
            task_data: Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

        Example:
            >>> await manager.notify_task_created(
            ...     {"id": str(task_id), "title": "ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°", ...}
            ... )
        """
        message = {"type": "task:created", "data": task_data}
        await self.broadcast(message)

    async def notify_task_deleted(self, task_id: UUID) -> None:
        """
        Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµÑ‚ Ğ²ÑĞµÑ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¾Ğ± ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸.

        Args:
            task_id: UUID ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

        Example:
            >>> await manager.notify_task_deleted(task_id)
        """
        message = {"type": "task:deleted", "data": {"id": str(task_id)}}
        await self.broadcast(message)

    # ===== ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ =====

    async def update_user_activity(
        self, user_id: str, status: str = "online"
    ) -> bool:
        """
        ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.

        Args:
            user_id: UUID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            status: ĞĞ¾Ğ²Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ (online, away, idle)

        Returns:
            bool: True ĞµÑĞ»Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½

        Example:
            >>> await manager.update_user_activity(user_id, "away")
        """
        user_id_str = str(user_id)

        if user_id_str not in self.authenticated_connections:
            return False

        conn = self.authenticated_connections[user_id_str]
        old_user = conn.user
        now = datetime.now(UTC).isoformat()

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ
        if old_user.status != status or old_user.last_activity_at != now:
            updated_user = OnlineUser(
                user_id=old_user.user_id,
                username=old_user.username,
                full_name=old_user.full_name,
                role=old_user.role,
                status=status,
                connected_at=old_user.connected_at,
                last_activity_at=now,
            )
            self.authenticated_connections[user_id_str] = AuthenticatedConnection(
                websocket=conn.websocket,
                user=updated_user,
            )

            # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²ÑĞµÑ… Ğ¾Ğ± Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
            if old_user.status != status:
                message = {
                    "type": "user:status",
                    "data": updated_user.to_dict(),
                }
                await self.broadcast(message)
                logger.debug(
                    "ğŸ”„ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ %s Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½: %s -> %s",
                    old_user.username,
                    old_user.status,
                    status,
                )

            return True

        return False
